# Null-able
Null-совместимые типы позволяют присваивать значимым типам значения null.
```
Nullable<Int32> ableNull = 5;
Nullable<Int32> ableNull1 = null;

Int32? x = 10;
Int32? y = null;
```
## Операции с null-able
- Унарные операции: если null, то останется null,
- Бинарные (+, -, \*, /, %, &, |, ^, <<, >>): null, если null хотя бы один операнд. Исключения: & и |
[!operand](./imgReadme/bin_ops_1.png)
- Операторы равенства (==, !=): если оба null - true, если лишь один null - false,
- Операторы сравнения (<, >, <=, >=): если значение null имеет хотя бы один из операндов, в результате получаем false. 
Если ни один из операндов не имеет значение null, следует сравнить их значения.

## Оператор объединения null-совместимых типов
```
int a = GetNullAbleInt() ?? 0; // если GetNullAbleInt() возвращает значение null - присваиваем значение, находящиеся справа от ??
int a = GetNullAbleInt1() ?? GetNullAbleInt2() ?? 0// 
```

## Поддержка в CLR null-совместимых значимых типов
### Упаковка null-совместимых значимых типов
При упаковке экземпляра Nullable<T> проверяется его равенство null и в случае положительного результата вместо упаковки возвращает null.
В противном случае CLR упаковывает значение экземпляра.
Другими словами, тип Nullable<Int32> со значением 5 упаковывается в тип Int32 с аналогичным значением.

### Распаковка null-совместимых значимых типов
В CLR упакованный значимый тип T распаковывается в T или в Nullable<T>. Если ссылка на упакованный значимый тип равна null и
выполняется распаковка в тип Nullable<T>, CLR приваивает Nullable<T> значение null.
### Вызов метода GetType через null-совместимый значимый тип
При вызове GetType для объекта типа Nullable<T> CLR выполняет тип T вместо Nullable<T>.
```
int? aa;
aa = null;
// Console.WriteLine(aa.GetType()); // NullReferenceException
aa = 5;
Console.WriteLine(aa.GetType()); // Int32
```

### Вызов интерфейсных методов через null-совместимый значимый тип
В приведенном далее фрагменте кода переменная n типа Nullable<Int32> приво-
дится к интерфейсному типу IComparable<Int32>. Но тип Nullable<T> в отличие от
типа Int32 не реализует интерфейс IComparable<Int32>. Тем не менее код успешно
компилируется, а механизм верификации CLR считает, что код прошел проверку,
чтобы вы могли использовать более удобный синтаксис.
```
Int32? n = 5;
Int32 result = ((IComparable) n).CompareTo(5); // Компилируется 
                                               // и выполняется
Console.WriteLine(result); // 0
```
Без подобной поддержки со стороны CLR пришлось бы писать громоздкий код
вызова интерфейсного метода через null-совместимый значимый тип. Для вызова
метода потребовалось бы приведение распакованного значимого типа перед при-
ведением к интерфейсу:
```
Int32 result = ((IComparable) (Int32) n).CompareTo(5); // Громоздкий код
```
```
int? aaa = 5;
Console.WriteLine(((IComparable)aaa).CompareTo(5));
aaa = null;
// Console.WriteLine(((IComparable)aaa).CompareTo(5)); // NullReferenceException
```